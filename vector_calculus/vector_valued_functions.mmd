# Vector valued functions

We discuss functions of a single variable that return a vector in $R^n$. There are many parallels to univariate functions (when $n=1$).


## Definition

A function $\vec{f}: R \rightarrow R^n, n > 1$ is called a vector valued function. Some examples:

$$~
\vec{f}(t) = \langle \sin(t), 2\cos(t) \rangle, \quad
\vec{g}(t) = \langle \sin(t), \cos(t), t \rangle, \quad
\vec{h}(t) = \langle 2, 3 \rangle + t \cdot \langle 1, 2 \rangle.
~$$

The components them selves are also functions of $t$, in this case
univariate functions. Depending on the context, it can be useful to
view these as a function that returns a vector, or a vector of the
component functions.


The above example functions have $n$ equal $2$, $3$, and $2$ respectively. We
will see that many concepts of calculus for univariate functions
($n=1$) have direct counterparts.


## Representation in Julia

In `Julia`, the representation of a vector valued function is straightforward: we define a function of a single variable that returns a vector. For example, the three functions above would be represented by:

```
f(t) = [sin(t), 2*cos(t)]
g(t) = [sin(t), cos(t), t]
h(t) = [2, 3] + t * [1, 2]
```

For a given `t`, these evaluate to a vector. For example:

```
h(2)
```

We can create a vector of functions, e.g. `F = [cos, sin, identify]` but calling this object, as in `F(t)` would require some work, such as `t = 1; [f(t) for f in F]`.




## Space curves

A vector-valued function is typically visualized as a parameterized
curve. That is, for some range, $a \leq t \leq b$ the set of points
$\{\vec{f}(t): a \leq t \leq b\}$ are plotted. That is, if, say in $n=2$, we
have $x(t)$ and $y(t)$ as the component functions, then the graph
would also be the parametric plot of $x$ and $y$.


This plot represents the vectors with their tails at the origin.

There is a convention for plotting the component functions to yield a parametric plot within the `Plots` package (e.g., `plot(x, y, a, b)`) but we will use a different approach, as the component functions are not naturally produced from the vector-valued function.

In `Plots`, the command `plot(xs, ys)`, where, say, `xs=[x1, x2, ..., xn]` and `ys=[y1, y2, ..., yn]`, will make a connect-the-dot plot between corresponding pairs of points. Similarly, were a third vector, `zs`, for $z$ components used. However, naturally can generate the vector of points: `[[x1,y1], [x2, y2], ..., [xn, yn]]`, as this comes from broadcasting `f` over some time values. That is, for collection of time values, `ts`, as typically generated by `range`, the command `f.(ts)` will produce the vector of points.

To get the `xs` and `ys` from this, is conceptually easy: just iterate of all the points and extract the corresponding component. E.g, to get `xs` we would have a command like `[p[1] for p in f.(ts)]`. Similarly, the `ys` would use `p[2]` in place of `p[1]`. The following  function does this for us, returning the vectors in a tupleL


```
xs_ys(vs) = Tuple(eltype(vs[1])[vs[i][j] for i in 1:length(vs)] for j in eachindex(first(vs)))
```

We define a few convenience functions, the first allows us to pass the vector of vectors entry by entry, the latter creates the values `f.(ts)` first from a specification of the interval `[a,b]` and the number of points, with a default of 100:

```
xs_ys(v,vs...) = xs_ys([v, vs...])
xs_ys(r::Function, a, b, n=100) = xs_ys(r.(range(a, stop=b, length=n)))
```

As also mentioned in [vectors][./vectors.html], plotting a vector can be simplified through through this interface:

```
function arrow!(plt::Plots.Plot, p, v; kwargs...)
  length(p) == 2 && return quiver!(plt, xs_ys([p])..., quiver=Tuple(xs_ys([v])); kwargs...)
  length(p) == 3 && return plot!(plt, xs_ys(p, p+v)...; kwargs...)
end
arrow!(p, v; kwargs...) = arrow!(Plots.current(), p, v; kwargs...)
```

With these definitions, we can visualize the three functions we have defined.

Here we show the plot of `f` over the values between $0$ and $2\pi$ and also add a vector anchored at the origin defined by `f(1)`.

```
using Plots
plot(xs_ys(f, 0, 2pi)...)
arrow!([0,0], f(1))
```

The trace of the plot is an ellipse. If we describe the components as $\vec{f}(t) = \langle x(t), y(t) \rangle$, then we have $x(t)^2 + y(t)^2/4 = 1$. That is, for any value of $t$, the resulting point satisfies the equation $x^2 + y^2/4 =1$ for an ellipse.


The plot of $g$ needs 3-dimensions to render. For most plotting backends, the following should work with no differences, save the additional vector is anchored in 3 dimensions now:

```
plot(xs_ys(g, 0, 6pi)...)
arrow!([0,0, 0], g(1))
```

Here the graph is a helix; three turns are plotted. If we write $g(t) = \langle x(t), y(t), z(t) \rangle$, as the $x$ and $y$ values trace out a circle, the $z$ value increases. Were the graph viewed from above, we would only see the $x$ and $y$ components, and the view would be circular.


The graph of $h$ shows that this function parameterizes a line in space. The line segment for $-2 \leq t \leq 2$ is shown below:

```
plot(xs_ys(h, -2, 2)...)
```


##### Example

Familiarity with equations for lines, circles, and ellipses is
important, as these fundamental geometric shapes are often building
blocks in the description of other more complicated things.

The point-slope equation of a line, $y = y_0 + m \cdot (x - x_0)$
findss an analog. The slope, $m$, is replaced with a vector $\vec{v}$
and the point, $(x_0, y_0)$ is replaced with a vector $\vec{p}$
identified with a point in the plane. A parameterization would then be
$f(t) = \vec{p} + (t - t_0) \vec{v}$. From this, we have $f(t_0) =
\vec{p}$.




The unit circle is instrumental in introducing the trigonometric
functions though the identification of and angle $t$ with a point on
the unit circle $(x,y)$ through $y = \sin(t)$ and $x=\cos(t)$. With
this identification certain properties of the trigonometric functions
are immediately seen, such as the period of $\sin$ and $\cos$ being
$2\pi$, or the angles for which $\sin$ and $\cos$ are positive or even
increasing. Further, this gives a natural parameterization for a
vector-valued function whose plot yields the unit circle, namely
$\vec{f}(t) = \langle \cost(t), \sin(t) \rangle$. This
parameterization starts (at $t=0$) at the point $(1, 0)$. More
generally, we might have additional parameters $\vec{f}(t) = \vec{p} +
R \cdot \langle \cost(\omega(t-t_0)), \sin(\omega(t-t_0)) \rangle$ to
change the origin, $\vec{p}$; the radius, $R$; the starting angle,
$t_0$; and the rotational frequency, $\omega$.


An ellipse, has a slightly more general equation than a circle, and in
simplest forms may satisfy the equation $x^2/a^2 +  y^2/b^2 = 1$, where *if*
$a=b$ a circle is being described. A vector valued function of the form
$\vec{f}(t) = \langle a\cdot\cos(t),  b\cdot\sin(t) \rangle$ will trace out an ellipse.


##### Example

The [Spirograph](https://en.wikipedia.org/wiki/Spirograph) is "... a geometric drawing toy that produces mathematical roulette curves of the variety technically known as hypotrochoids and epitrochoids. It was developed by British engineer Denys Fisher and first sold in 1965." These can be used to make interesting geometrical curves.

Following Wikipedia: Consider a fixed outer circle $C_o$  of radius $R$ centered at the origin. A smaller inner circle  $C_i$ of radius $r<R$ rolling inside $C_o$ and is continuously tangent to it. $C_{i}$ will be assumed never to slip on $C_{o}$ (in a real Spirograph, teeth on both circles prevent such slippage). Now assume that a point $A Alying somewhere inside $C_{i}$is located a distance $\rho <r$ from $C_{i}$'s center.

The center of the inner circle will move in a circular manner with radius $R-r$. The fixed point on the inner circle will rotate about this center. The accumulated angle may be described by the angle the point of contact of the inner circle with the outer circle. Call this angle $t$.

Suppose the outer circle is centered a the origin and the inner circle starts ($t=0$) with center $(R-r, 0)$ and rotates around counterclockwise. Then if the point of contact makes angle $t$, the arc length along the outer circle if $Rt$. The inner circle will have moved a distance $r t'$ in the opposite direction, so $Rt =-r t'$ and solving the angle will be $t' = -(R/r)t$.

If the initial position of the fixed point is at $(rho, 0)$ relative to the origin, then the following function will describe the motion:

$$~
\vec{s}(t) = (R-r) \cdot \langle \cos(t), \sin(t) \rangle +
rho \cdot \langle \cos(\frac{R}{r}t), \sin(\frac{R}{r}t) \rangle.
~$$



To visualize this we first define a helper function to draw a circle at point $P$ with radius $R$:

```
function circle!(plt, P, R; kwargs...)
	plot!(xs_ys(t -> P + R*[cos(t), sin(T)], 0, 2pi)...)
end
circle!(P, R; kwargs...) = circle!(Plots.current(), P, R; kwargs...)
```

Then we have this function to visualize the spirograph for different $t$ values:

```
function spiro(t; r=2, R=5, rho=0.8*r)

    cent(t) = (R-r) * [cos(t), sin(t)]

    p = plot(legend=false)
    circle!(p, [0,0], R)
    circle!(p, cent(t), r)

    tp(t) = -R/r * t

    s(t) = cent(t) + rho * [cos(tp(t)), sin(tp(t))]
    plot!(xs_ys(s, 0, t, 1000)...)

    p
end
```

And we can see the trace for $t=\pi$:

```
spiro(pi)
```

The point of contact is at $(-R, 0)$, as expected. Carrying this forward to a full circle's worth is done through:

```
spiro(2pi)
```

The curve does not match up at the start. For that, a second time around the outer circle is needed:

```
spiro(2pi)
```

Whether the curve will have a period or not is decided by the ratio of $R/r$ being rational or irrational.


```
R, r = 25, 5
rho = 0.8*r

f(t) = (R-r)*[cos(t), sin(t)] + rho * [cos((R-r)/r * t), -sin((R-r)/r * t)]

plot(xs_ys(f, 0, 2pi, 1000), aspect_ratio=:equal)
```

##### Example

[Ivars Peterson](http://www.phschool.com/science/science_news/articles/tilt_a_whirl.html) described the carnival ride "tilt-a-whirl" as a chaotic system, whose equations of motion are presente in [American Journal of Physics](https://doi.org/10.1119/1.17742) by Kautz and Huggard. The tilt-a-whirl has a platform that moves in a circle that also moves up and down. To describe the motion of a point on the platform assuming it has radius $R$ and period $T$ and rises twice in that period could be done with the function:

$$~
\vec{u}(t) = \langle R \sin(2\pi t/T), R \cos(2\pi t/T), h + h \cdot \sin(2\pi t/ T) \rangle.
~$$

A passenger sits on a circular platform with radius $r$ attached at some point on the larger platform. The dynamics of the person on the tilt-a-whirl depend on physics, but for simplicity, let's assume the platform moves at a constant rate with period $S$ and has no relative $z$ component. The motion of the platform in relation to the point it is attached would be modeled by:

$$~
\vec{v}(t) = \langle r \sin(2\pi t/S), r \sin(2\pi t/S), 0 \rangle.
~$$

And the motion relative to the origin would be the vector sum, or superposition:

$$~
\vec{f}(t) = \vec{u}(t) + \vec{v}(t).
~$$

To visualize for some parameters, we have:

```
R, r = 25, 5
height = 5
S, T = 8, 2
u(t) = [R * sin(2pi*t/T), R * cos(2pi*t/T), height*(1 +sin(2pi * t/T))]
v(t) = [r * sin(2pi*t/S), r * cos(2pi*t/S), 0]
f(t) = u(t) + v(t)
plot(xs_ys(f, 0, 8, 1000)...)
```

## limits

The definition of a limit for a univariate function is: For every $\epsilon > 0$ there exists a $\delta > 0$ such that *if* $0 \leq |x-c| < \delta$ *then* $|f(x) - L | < \epsilon$.

If this the notion of $f$ is close to $L$ is replaced by close in the sense of a norm, then the same limit definition can be used, with the new wording "... $\| \vec{f}(x) - L \| < \epsilon$".

A consequence of the triangle inequality is that a vector-valued function is continuous if and only it its component functions are.

## derivatives

If $\vec{f}(t)$ is  vector valued,  and $\Delta t > 0$ then we can consider the vector:

$$~
\vec{f}(t + \Delta t) - \vec{f}(t)
~$$

For example, if $\vec{f}(t) = \langle \sin(t), 3\cos(t) \rangle$ and $t=\pi/4$ and $\Delta t = \pi/16$ we have this picture:

```
gr()
f(t) = [sin(t), 3cos(t)]
t, Deltat = pi/4, pi/16
df = f(t + Deltat) - f(t)
plot(legend=false)
arrow!([0,0], f(t))
arrow!([0,0], f(t+Deltat))
arrow!(f(t), df)
```

The length of the difference appears to be related to the length of $\Delta t$, in a similar manner as the univariate derivative. The following limit defines the *derivative* of a vector-valued function:

$$~
\vec{f}'(t) = \lim_{\Delta t \rightarrow 0} \frac{f(t + \Delta t) - f(t)}{\Delta t}.
~$$

The limit exists if the component limits do. The component limits are just the derivatives of the component functions. So, if $\vec{f}(t) = \langle x(t), y(t) \rangle$, then $\vec{f}'(t) = \langle x'(t), y'(t) \rangle$.

The derivative is a tangent vector to the parameterized curve, akin to the case for a univariate function. We can use `ForwardDiff` to compute derivative in the exact same manner as was done for univariate functions:

```
using ForwardDiff
D(f,n=1) = n > 1 ? D(D(f),n-1) : x -> ForwardDiff.derivative(f, x)
Base.adjoint(f::Function) = D(f)         # allow f' to compute derivative
```

We can visualize the tangential property through a graph:

```
f(t) = [sin(t), 3cos(t)]
p = plot(xs_ys(f, 0, 2pi)..., legend=false)
for t in [1,2,3]
    arrow!(p, f(t), f'(t))   # add arrow with tail on curve, in direction of derivative
end
p
```


### Symbolic representation

Were symbolic expressions used in place of functions, the vector-valued function would naturally be represented as a vector of expressions:

```
using SymPy
@vars t
vvf = [sin(t), cos(t), t]
```

We will see working with these expressions is not idential to working with a vector-valued function.

To plot, we can avail ourselves of the the parametric plot syntax. The following expands to `plot(sin(t), cos(t), t, 0, 2pi)`:

```
plot(vvf..., 0, 2pi)
```

The `xs_ys` usage, as was done above, could be used, but it would be much more trouble in this case.

To evalute the function at a given value, say $t=2$, we can use `subs` with broadcasting to substitute into each component:

```
subs.(vvf, t.=>2)
```

The notation is a bit subtle: `subs.(` will broadcast over the 3 components in `vvf`. This is familiar, but broadcasting tries to match up sizes of collections. Without a "dot", `vvf` would have size 3 and `t=>2` has size 2 as an iterable object; and this causes a mismatch. We need to make `t=>2` appear to have just length 1. The `t.=>2` expresses this, also would wrapping in a tuple, as in `(t=>2, )` or using `Ref`, as in `Ref(t=>2)` would have worked.


Limits are performed component by component, and can also be defined by broadcasting, again with the need to adjust the values:

```
@syms delta
limit.((subs.(vvf, t .=> t + delta) - vvf) / delta, delta .=> 0)
```


Derivatives, as was just done through a limit, are a bit more
straightforward than evaluation or limit taking, as we won't bump into
the shape mismatch:

```
diff.(vvf, t)
```

```
note("""
If these differences are too subtle, it might be best to work with a function and when a symbolic expression is desirable, simply evaluate the function for a symbolic value.
""")
```

### Applications of the derivative


The derivative of a vector valued function is similar to that of a univariate function, in that it indicates a direction tangent to a curve. To parameterize this line uses the point-slope form. We have a point given through the vector-valued function and a direction given by its derivative. (After identifying a vector with its tail at the origin with the point that is the head of the vector.)

With this, the equation is simply $\vec{tl}(t) = \vec{f}(t_0) + \vec{f}'(t_0) \cdot (t - t_0)$, where the dot indicates scalar multiplication.


##### Example: tractrix

https://en.wikipedia.org/wiki/Tractrix
https://sinews.siam.org/Details-Page/a-bike-and-a-catenary
https://www.math.psu.edu/tabachni/talks/BicycleDouble.pdf


A [tractrix](https://en.wikipedia.org/wiki/Tractrix), studied by Perrault, Newton, Huygens, and many others, is the curve along which an object moves when pulled in a horizontal plane by a line segment attached to a pulling point (Wikipedia). If the object is placed at $(a,0)$ and the puller at the origin, and the puller moves along the positive $x$ axis, then the line will always be tangent to the curve and of fixed length, so determinable from the motion of the puller. In this example $dy/dx = -\sqrt{a^2-x^2}/x$.

This is the key property: "Due to the geometrical way it was defined, the tractrix has the property that the segment of its tangent, between the asymptote and the point of tangency, has constant length $a$."

As a bicyle moves, the motion of the rear wheel relative to the front is a fixed length and such that the direction of motion of the rear wheel points to the front wheel. That is, the paths follow a tractrix. If we start with the rear wheel (the object) above, we can readily describe the curve for the front wheel by plotting the tangent line with length 1.

For example, if the rear wheel moves according to the following parametric equation, we can plot both the rear wheel and the front wheel:

```
using LinearAlgebra
a, b = 0, 4
t1, t2 = 3/4, 3/2
rw(t) = [t, t/2 + sin(t)]
plot(xs_ys(rw, a, b,1000)...)

uvec(v) = v/norm(v)

fw(t) = rw(t) + uvec(rw'(t))
plot!(xs_ys(fw, a, b,1000)...)

arrow!(rw(t1), uvec(rw'(t1)))
arrow!(rw(t2), uvec(rw'(t2)))
```


XXX more challenging is identifying the motion of the rear wheel from the front. Paper, ...


### Derivative rules.

Clearly from the definition, it should be clear that for vector-valued functions $\vec{f}, \vec{g}: R \rightarrow R^n$ we would have:

$$~
[\vec{f} + \vec{g}]'(t) = \vec{f}'(t) + \vec{g}'(t), \quad\text{and }
[a\vec{f}]'(t) = a \vec{f}'(t).
~$$

If $s$ is a univariate function, then the composition $\vec{f}(s(t))$ can be differentiated. Each component would satisfy the chain rule, and consequently:

$$~
\frac{d}{dt}\left(\vec{f}(s(t))\right) = \vec{f}'(s(t)) \cdot s'(t),
~$$

The dot being scalar multiplication by the derivative of the univariate function $s$.

Vector valued functions do not have multiplication or division defined for them, so there are no ready analogues of the product and quotient rule. However, the dot product and the cross product produce new functions that may have derivative rules available.

For the dot product, the combination $\vec{f}(t) \cdot \vec{g}(t)$ we have a univariate function of $t$, so we know a derivative is well defined. Can it be represented in terms of the vector-valued functions? In terms of the component functions, we have this calculuation specific to $n=2$, but that which can be generalized:

$$~
\frac{d}{dt}(\vec{f}(t) \cdot \vec{g}(t)) =
\frac{d}{dt}(f_1(t) g_1(t) + f_2(t) g_2(t)) =
f_1'(t) g_1(t) + f_1(t) g_1'(t) + f_2'(t) g_2(t) + f_2(t) g_2'(t) =
f_1'(t) g_1(t) + f_2'(t) g_2(t) + f_1(t) g_1'(t)  + f_2(t) g_2'(t) =
\vec{f}'(t)\cdot \vec{g}(t) + \vec{f}(t) \cdot \vec{g}'(t).
~$$

Suggesting the that a product rule like formula applies for dot products.


For the cross product, we let `SymPy` derive a formula for us.

```
@symfuns u1 u2 u3 v1 v2 v3
@vars t
u = [u1(t), u2(t), u3(t)]
v = [v1(t), v2(t), v3(t)]
```

Then the cross product a derivative:

```
using LinearAlgebra
diff.(u × v, t)
```

Admittedly, that isn't very clear. With a peek at the answer, we show that the derivative is the same as the product rule would suggest ($\vec{u}' \times \vec{v} + \vec{u} \times \vec{v}'$):

```
diff.(u × v, t) - (diff.(u,t) × v + u × diff.(v,t))
```


##### Application. Circular motion and the tangent vector.

The parameterization $\vec{r}(t) = \langle \cos(t), \sin(t) \rangle$ describes a circle. Characteristic of this motion is a constant radius, or in terms of a norm: $\| \vec{r}(t) \| = c$. The norm squared, can be expressed in terms of the dot product:

$$~
\| \vec{r}(t) \|^2 = \vec{r}(t) \cdot \vec{r}(t).
~$$

Differentiating this for the case of a constant radius yields the equation $0 = [\vec{r}\cdot\vec{r}]'(t)$, which simplifies through the product rule to $0 = 2 \vec{r}(t) \cdot \vec{r}'(t)$. That is, the two vectors are perpendicular to each other.


## XX KEPLER, ..,

### T, B, N

## curvature, torsion


## Arc length
